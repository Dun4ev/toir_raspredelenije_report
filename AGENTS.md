# Регламент репозитория

## Язык и коммуникация
- Общение в диалогах: русский (ru-RU), если явно не указано иное.
- Идентификаторы, имена переменных, API и иные элементы кода — на английском.
- Комментарии и докстринги — на русском (Google-style docstrings).
- При возникновении неоднозначности — уточнять требования на русском.

## Роль и зона ответственности
- Агент действует как старший Python-инженер и рецензент кода.
- Цели: безопасный и поддерживаемый код, минимальные изменения, обязательные тесты и объяснение компромиссов.
- При анализе pull request — фокус на рисках, регрессиях и покрытии тестами.

## Обзор проекта и ключевые функции
- Приложение автоматизирует обработку отчётов ТОиР и ведение журналов; проект эволюционировал из одиночного скрипта в модульную систему с `src-layout`.
- **Автоматическая сортировка**: сканирует входную директорию, парсит имена `_All.pdf` и распределяет файлы по целевым каталогам.
- **Архивация**: создаёт zip-архивы исходных проектных папок в структуре `Native`.
- **Журналирование**: протоколирует каждое действие в `.jsonl`-логах, пригодных для UI и CLI-отчётов.
- **Интерфейсы**: предоставляет CLI-команды и настольный UI; при `APP_HEADLESS=1` UI не запускается.
- **Поиск `_All`**: рекурсивно обходит `INBOX_DIR`, определяя проект по каталогу, где найден `_All.pdf`; остальные операции выполняются относительно этой папки.

## Формат ответов
1. Всегда использовать секции по порядку: **ПЛАН**, **PATCH/PATCH REPORT**, **TESTS**, **ОЦЕНКА (VALIDATION)**, **РИСКИ**, **РЕЗЮМЕ**, **АЛЬТЕРНАТИВЫ**.
2. Патчи не вставлять inline. Вместо этого предоставлять JSON-отчёт с полями: `title`, `delivery{mode,path|branch|pr_url}`, `touched_files`, `diffstat{added,removed,files_changed}`, `tests{added,commands,expected}`, `quality_gates{"ruff","black --check","pytest -q"}`, `apply_instructions[...]`, `risk_level`, `breaking_changes`, `migration_notes`, `diagnostics`.
3. Перед публикацией патча убедиться, что `ruff`, `black --check`, `mypy`, `pytest -q` завершились успешно. При провале — сообщить диагноз без публикации патча.
4. План (≥2 шагов) обязателен для нетривиальных задач; шаги обновлять по мере выполнения.
5. Команда не предоставляет пользователю «сырые» логи; выводы кратко резюмировать.

## Структура проекта и архитектура
- Используется src-layout: пакет `src/toir_manager` с уровнями `core`, `services`, `ui`, `cli`; слои импортируют только вниз по направлению (`core` изолирован от IO, `services` опирается на `core`, `ui` использует оба).
- Основные точки входа: `src/toir_manager/__main__.py` (CLI/UI), `run_ui.py` (быстрый запуск UI), устаревший сценарий `toir_raspredelenije.py` сохраняет оркестрацию пакетной обработки.
- Конфигурации (`Template/`, `templates/`, `logs/dispatch/`) отделены от логики; пути можно переопределить переменными окружения `TOIR_*`.

```
repo/
|- toir_raspredelenije.py      # текущий конвейер распределения PDF
|- run_ui.py                   # точка входа для настольного интерфейса
|- src/toir_manager/           # приложение в формате пакета
|  |- __main__.py              # выбор CLI или UI
|  |- core/                    # модели логирования и чистая логика
|  |- services/                # работа с логами, настройками и IO
|  |- cli/                     # команды отчётности
|  |- ui/                      # Tkinter-интерфейс
|- logs/dispatch/              # JSONL-журналы прогонов
|- Template/, templates/       # конфигурации и шаблоны
|- tests/                      # набор pytest
```

- `core/logging_models.py` описывает `TransferAction`, `TransferStatus`, `TransferLogEntry` и другие структуры данных.
- `services/log_writer.py` реализует `DispatchLogger` для потокобезопасной записи `.jsonl`; `services/log_reader.py` обслуживает чтение и агрегацию журналов.
- `cli/report.py` и UI-слой дают доступ к журналам и управлению прогоном; при `APP_HEADLESS=1` UI принудительно отключается.

## Запуск и использование
- `python toir_raspredelenije.py` — базовая обработка входного каталога.
- `TOIR_INBOX_DIR=... python toir_raspredelenije.py` — запуск с альтернативным INBOX.
- `python run_ui.py --base-dir logs/dispatch` — быстрый просмотр журналов в UI.
- `python -m toir_manager report --base-dir logs/dispatch --json` — CLI-выгрузка логов.
- Для всех запусков требуется активное виртуальное окружение и корректно настроенные пути `TOIR_*`.

## Алгоритм обработки INBOX
1. Входной `_All.pdf` размещается в целевой подпапке `INBOX_DIR`; глубина вложенности произвольная.
2. Скрипт рекурсивно находит `_All` и определяет проект по каталогу, где лежит файл.
   Переменная окружения `TOIR_PART_FILTER` позволяет ограничить обработку частью (`LP`, `CS`, `CS/LP` по умолчанию).
- Для раздела CS скрипт автоматически ищет каталоги `pdf` и `Native`; при отсутствии создает их по справочнику `CS_DEFAULT_FOLDERS` (и логирует, найден или создан).
- Период 'C'/'С' всегда направляется в папку 'Корректирующее обслуживание' для CS, даже при кириллическом символе.
3. PDF-файл копируется в `03_Notes`, `04_TRA_GST`, `05_TRA_SUB_app`, целевой `DEST_ROOT_DIR/pdf` с учётом настроек и флагов.
4. Формируется архив в `DEST_ROOT_DIR/Native`; временный архив хранится в `TEMP_ARCHIVE_DIR`.
5. Все действия фиксируются в `logs/dispatch/<run_id>.jsonl`; UI и CLI читают эти журналы.

## UI
- Вкладка «Распределение» (`run_ui.py`): запуск обработки, просмотр stdout/stderr, открытие целевых директорий.
- Вкладка «Журналы»: список прогонов, таблица файлов, массовое открытие директорий, очистка старых логов.
- Выпадающий список позволяет выбрать фильтр части (`LP`/`CS`/`CS/LP`); выбор сохраняется и управляет `TOIR_PART_FILTER` для распределения.
- При `APP_HEADLESS=1` интерфейс не стартует, даже если указан флаг `--ui`.

## Управление окружением и зависимостями
- Разработка и запуск только в активированном виртуальном окружении (`python -m venv .venv`, активация через `.venv\Scripts\activate` или `source .venv/bin/activate`).
- Зависимости ведутся через `requirements.in` и `pip-compile`; установка — `pip install -r requirements.txt`.
- Папка окружения (.venv/venv) добавлена в `.gitignore` и не коммитится.

- Параметры `TOIR_*` (включая `TOIR_PART_FILTER`) управляют путями и фильтрацией. При некорректном значении фильтра используется `CS/LP`.

## Стиль кода и качество
- Python ≥ 3.10, PEP 8, строгая типизация публичных API.
- Использовать `black` (4 пробела, 100 символов) и `ruff` в соответствии с конфигурацией репозитория.
- Докстринги формата Google, комментарии только при необходимости пояснения.

## Тестирование и проверки
- Тесты в `tests/`, запуск `pytest -q`.
- Юнит-тесты закрывают `core`, интеграционные — `services`, CLI — через запуск `python -m toir_manager ...`.
- UI-smoke тесты выполняются отдельно; медленные тесты помечаются `@slow`.
- Любое исправление бага начинается с падающего теста.

## Работа с документацией
- При изменении поведения обновлять `README.md`; правки регламента фиксировать в этом документе (`AGENTS.md`).
- В случае архитектурных решений фиксировать ADR в `docs/`.
- Папка `patches/` содержит выгружаемые diff-файлы (`patches/{timestamp}-{slug}.diff`).

## Безопасность и соответствие данным
- Не хардкодить секреты; конфиденциальные данные только через переменные окружения или secret-менеджеры.
- Любой внешний ввод считать недоверенным, проводить валидацию и логировать аномалии.
- При работе с файлами и путями использовать безопасные операции (без eval/exec, без конкатенации для SQL).
- Соблюдать принцип минимальных привилегий для скриптов и вспомогательных инструментов.

## Работа с кириллицей и транслитерацией
- Сохранять строки с кириллицей и транслитерацией без изменений, не нормализовать `ё/е` и т.п.
- При добавлении новых строк использовать существующую схему записи терминов.
- Все текстовые файлы — UTF-8.

## Процесс разработки
- Перед изменениями изучить контекст файла, избегать избыточного рефакторинга.
- Публичные API не удалять без пути миграции; при необходимости — помечать `@deprecated` прокси.
- Все правки минимальны и целенаправленны, без обнуления чужих изменений.
- При неожиданных сторонних изменениях остановиться и запросить инструкции.

## Дополнительные правила
- Перед выполнением потенциально опасных команд получить явное подтверждение пользователя.
- Для простых запросов допускаются прямые команды (например, `date`).
- Сохранять отчетность по рискам и тестам в итоговом ответе.
- При невозможности выполнить задачу подробно описать препятствия.
